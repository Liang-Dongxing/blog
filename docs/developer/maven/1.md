# Maven 打包分离 jar 包里的 lib 依赖

## 在需要拆分的模块中添加 Maven 配置
```xml
    <build>
        <finalName>${project.artifactId}</finalName>
        <!-- 设置应用 Main 参数启动依赖查找的地址指向外部 lib 文件夹 -->
        <plugins>
            <!-- 设置将 lib 拷贝到应用 Jar 外面 -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <executions>
                    <execution>
                        <id>copy-dependencies</id>
                        <!-- phase 配置的是 build 的生命周期  -->
                        <phase>prepare-package</phase>
                        <goals>
                            <goal>copy-dependencies</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.directory}/lib</outputDirectory>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <configuration>
                    <archive>
                        <!-- 向清单添加类路径条目  -->
                        <manifest>
                            <addClasspath>true</addClasspath>
                            <!-- 项目所依赖的jar位于同一级的lib目录下-->
                            <classpathPrefix>lib/</classpathPrefix>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <fork>true</fork> <!-- 如果没有该配置，devtools不会生效 -->
                    <!-- 导入系统路径包 -->
                    <includeSystemScope>true</includeSystemScope>
                    <includes>
                        <include>
                            <groupId>nothing</groupId>
                            <artifactId>nothing</artifactId>
                        </include>
                    </includes>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
```

## 使用到的maven插件
- [maven-dependency-plugin](https://maven.apache.org/plugins/maven-dependency-plugin/)
- [maven-jar-plugin](https://maven.apache.org/plugins/maven-jar-plugin/)
- [spring-boot-maven-plugin](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/)

## Dependency plugin 有几个目标：
| 目标                                | 描述                                                                                 |
|:----------------------------------|:-----------------------------------------------------------------------------------|
| dependency:analyze                | 分析该项目的依赖关系并确定哪些是：已使用和已声明；已使用且未申报；未使用和声明。                                           |
| dependency:analyze-dep-mgt        | 分析您的项目依赖项并列出已解决的依赖项与 dependencyManagement 部分中列出的依赖项之间的不匹配项。                        |
| dependency:analyze-only           | 与 analyze 相同，但要绑定在 pom 中。它不会分叉构建并执行测试编译。                                           |
| dependency:analyze-report         | 分析该项目的依赖关系并生成一份报告，总结哪些是：使用的和声明的；已使用且未申报；未使用和声明。                                    |
| dependency:analyze-duplicate      | 分析 pom.xml 中的<dependencies/>和<dependencyManagement/>标签并确定重复声明的依赖项。                 |
| dependency:build-classpath        | 告诉 Maven 以类路径格式从本地存储库输出依赖项的路径，以便在 java -cp 中使用。类路径文件也可以与主要工件一起附加和安装/部署。            |
| dependency:copy                   | 获取插件配置部分中定义的工件列表，并将它们复制到指定位置，如果需要，重命名它们或删除版本。如果远程存储库中的工件不存在于本地存储库或反应器中，则此目标可以解析它们。 |
| dependency:copy-dependencies      | 获取项目直接依赖项和可选的传递依赖项的列表，并将它们复制到指定位置，如果需要，删除版本。这个目标也可以从命令行运行。                         |
| dependency:display-ancestors      | 显示项目的所有祖先 POM。这在持续集成系统中可能很有用，在该系统中您想知道项目的所有父 pom。这个目标也可以从命令行运行。                    |
| dependency:get                    | 从指定的远程存储库解析单个工件，最终传递。                                                              |
| dependency:go-offline             | 告诉 Maven 解决该项目所依赖的所有内容（依赖项、插件、报告），为下线做准备。                                          |
| dependency:list                   | resolve 的别名，它列出了这个项目的依赖项。                                                          |
| dependency:list-classes           | 显示在指定工件中找到的所有类的完全包限定名称。                                                            |
| dependency:list-repositories      | 显示所有项目依赖项，然后列出使用的存储库。                                                              |
| dependency:properties             | 为每个包含文件系统上的工件的项目依赖项设置一个属性。                                                         |
| dependency:purge-local-repository | 告诉 Maven 从本地存储库中清除依赖工件文件，并可选择重新解析它们。                                               |
| dependency:resolve                | 告诉 Maven 解析所有依赖项并显示版本。JAVA 9 注意： 使用 Java 9 运行时将显示模块名称。                             |
| dependency:resolve-plugins        | 告诉 Maven 解析插件和它们的依赖关系。                                                             |
| dependency:sources                | 告诉 Maven 解析所有依赖项及其源附件，并显示版本。                                                       |
| dependency:tree                   | 显示这个项目的依赖关系树。                                                                      |
| dependency:unpack                 | 像 copy 但解包。                                                                        |
| dependency:unpack-dependencies    | 像 copy-dependencies 但解包。                                                           |

## Maven Build 生命周期

| 生命周期阶段                            | 描述                                   |
|:----------------------------------|:-------------------------------------|
| validate（校验）                      | 校验项目是否正确并且所有必要的信息可以完成项目的构建过程。        |
| initialize（初始化）                   | 初始化构建状态，比如设置属性值。                     |
| generate-sources（生成源代码）           | 生成包含在编译阶段中的任何源代码。                    |
| process-sources（处理源代码）            | 处理源代码，比如说，过滤任意值。                     |
| generate-resources（生成资源文件）        | 生成将会包含在项目包中的资源文件。                    |
| process-resources （处理资源文件）        | 复制和处理资源到目标目录，为打包阶段最好准备。              |
| compile（编译）                       | 编译项目的源代码。                            |
| process-classes（处理类文件）            | 处理编译生成的文件，比如说对Java class文件做字节码改善优化。  |
| generate-test-sources（生成测试源代码）    | 生成包含在编译阶段中的任何测试源代码。                  |
| process-test-sources（处理测试源代码）     | 处理测试源代码，比如说，过滤任意值。                   |
| generate-test-resources（生成测试资源文件） | 为测试创建资源文件。                           |
| process-test-resources（处理测试资源文件）  | 复制和处理测试资源到目标目录。                      |
| test-compile（编译测试源码）              | 编译测试源代码到测试目标目录.                      |
| process-test-classes（处理测试类文件）     | 处理测试源码编译生成的文件。                       |
| test（测试）                          | 使用合适的单元测试框架运行测试（Juint是其中之一）。         |
| prepare-package（准备打包）             | 在实际打包之前，执行任何的必要的操作为打包做准备。            |
| package（打包）                       | 将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。 |
| pre-integration-test（集成测试前）       | 在执行集成测试前进行必要的动作。比如说，搭建需要的环境。         |
| integration-test（集成测试）            | 处理和部署项目到可以运行集成测试环境中。                 |
| post-integration-test（集成测试后）      | 在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。      |
| verify （验证）                       | 运行任意的检查来验证项目包有效且达到质量标准。              |
| install（安装）                       | 安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。       |
| deploy（部署）                        | 将最终的项目包复制到远程仓库中与其他开发者和项目共享。          |
